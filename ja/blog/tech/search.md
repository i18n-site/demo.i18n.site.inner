---

brief: |
  i18n.siteはサーバーレスの全文検索をサポートするようになりました。

  この記事では、IndexedDBによって構築された転置インデックス、接頭辞検索、単語分割の最適化、および多言語サポートを含む、純粋なフロントエンド全文検索テクノロジの実装について説明します。

  既存のソリューションと比較して、i18n.siteの純粋なフロントエンド全文検索はサイズが小さく高速であり、ドキュメントやブログなどの中小規模のWebサイトに適しており、オフラインで利用できます。

---

# 純粋なフロントエンド逆引き全文検索

## 順序

数週間の開発を経て、[i18n.site](//i18n.site)(純粋な静的マークダウン多言語翻訳およびWebサイト構築ツール)は、純粋なフロントエンド全文検索をサポートするようになりました。

<p style="display:flex;flex-wrap:wrap;justify-content:center"><img src="//p.3ti.site/1727600475.avif" style="width:320px"><img src="//p.3ti.site/1727602760.avif" style="width:320px"></p>

この記事では、`i18n.site`の純粋なフロントエンド全文検索の技術的な実装について説明します。[i18n.site](//i18n.site)にアクセスして検索効果を体験してください。

コードオープンソース:[検索カーネル](//github.com/i18n-site/ie/tree/main/qy) / [インタラクティブインターフェイス](//github.com/i18n-site/plugin/tree/main/qy)

## サーバーレス全文検索ソリューションのレビュー

ドキュメントや個人のブログなど、中小規模の純粋に静的な Web サイトの場合、独自に構築した全文検索バックエンドを構築するのは面倒すぎるため、サーバーレスの全文検索がより一般的な選択肢となります。

サーバーレス全文検索ソリューションは、次の2つの大きなカテゴリに分類できます

まず、全文検索用のフロントエンドコンポーネントを提供する[algolia.com](//algolia.com)サードパーティ検索サービスプロバイダーと同様です。

このようなサービスは検索ボリュームに応じて料金を支払う必要があり、ウェブサイトのコンプライアンスなどの問題により、中国本土のユーザーは利用できないことがよくあります。

オフラインやイントラネットでは使用できず、大きな制限があります。この記事ではそれについてはあまり議論しません。

2つ目は、純粋なフロントエンドの全文検索です。

現在、一般的な純粋なフロントエンド全文検索には[lunrjs](//lunrjs.com)および[ElasticLunr.js](//github.com/weixsong/elasticlunr.js)(`lunrjs`の二次開発に基づく)が含まれます。

`lunrjs`でインデックスを構築するには2つの方法があり、どちらにも独自の問題があります。

1. 事前に構築されたインデックスファイル

   なぜなら、索引にはすべての文書の単語が含まれているため、かさばります。
   いつでもドキュメントが追加または変更されると、新しいインデックスファイルをロードする必要があります。
   これにより、ユーザーの待ち時間が長くなり、大量の帯域幅が消費されます。

2. ロードされたドキュメントをその場でインデックスを構築します

   インデックスの構築は、大量の計算を必要とするタスクです。アクセスするたびにインデックスを再構築すると、明らかな遅延が発生し、ユーザー エクスペリエンスが低下します。

---

`lunrjs`に加えて、次のような他の全文検索ソリューションもあります

[fusejs](//www.fusejs.io)は、検索用の文字列間の類似性を計算します。

このソリューションのパフォーマンスは非常に低く、全文検索には使用できません([Fuse.jsの長いクエリには10秒以上かかります。最適化するには?](//stackoverflow.com/questions/70984437/fuse-js-takes-10-seconds-with-semi-long-queries)を参照)。

ブルームフィルターを使用して検索する[TinySearch](//github.com/tinysearch/tinysearch)は、接頭辞検索(たとえば、`goo`を入力し、`good`、`google`を検索)には使用できず、同様の自動補完効果を実現できません。

既存のソリューションには欠点があるため、`i18n.site`は次の特性を備えた新しい純粋なフロントエンド全文検索ソリューションを開発しました

1. 多言語検索に対応しており、サイズもコンパクトです。`gzip`でパッケージ化した後の検索カーネルのサイズは`6.9KB`です(比較のために、`lunrjs`のサイズは`25KB`です)
1. `indexedb`に基づいて転置インデックスを構築します。これはメモリ消費量が少なく、高速です
1. ドキュメントが追加/変更された場合、追加または変更されたドキュメントのみが再インデックスされるため、計算量が削減されます
1. 接頭辞検索をサポートし、ユーザーが入力中に検索結果をリアルタイムに表示できます
1. オフラインで利用可能

以下に、`i18n.site`の技術実装の詳細を詳しく紹介します。

## 多言語単語の分割

単語の分割にはブラウザのネイティブの単語分割`Intl.Segmenter`が使用され、すべての主流ブラウザがこのインターフェイスをサポートしています。

![](//p.3ti.site/1727667759.avif)

単語分割`coffeescript`コードは次のとおりです

```coffee
SEG = new Intl.Segmenter 0, granularity: "word"

seg = (txt) =>
  r = []
  for {segment} from SEG.segment(txt)
    for i from segment.split('.')
      i = i.trim()
      if i and !'|`'.includes(i) and !/\p{P}/u.test(i)
        r.push i
  r

export default seg

export segqy = (q) =>
  seg q.toLocaleLowerCase()
```

その中で:

* `/\p{P}/`は、句読点の一致に使用される正規表現パターンです。一致する特定の記号は次のとおりです。 `! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~。 `.</p><ul><li> `split('.')` は、`Firefox` ブラウザの単語分割が `.` を分割しないためです。</li>


## インデックスの構築

`IndexedDB`データベースには5つのオブジェクトストレージテーブルが含まれます

* `word` : id - 単語
* `doc` : id - ドキュメントURL - ドキュメントバージョン番号
* `docWord` : ドキュメントid - 単語idの配列
* `prefix` : プレフィックス - 単語idの配列
* `rindex` : 単語id - ドキュメントid : 行番号の配列

ドキュメント`url`とバージョン番号`ver`の配列を渡し、ドキュメントがテーブル`doc`に存在するかどうかを確認します。存在しない場合は、転置インデックスを作成します。同時に、入力に含まれていないドキュメントの逆索引エントリを削除します。

これにより、増分インデックスが実現され、計算負荷が軽減されます。

フロントエンドの対話に関しては、初期ロード時の遅延を防ぐために、インデックス作成の進行状況バーを表示できます。 「アニメーション付きプログレスバー: 単一のプログレス + 純粋なCSS実装」[英語](//dev.to/i18n-site/a-single-progress-uses-pure-css-to-achieve-animation-effects-2oo)/[中国語](//juejin.cn/post/7413586285954154522)を参照してください。

### IndexedDBの高同時書き込み

このプロジェクトは、[idb](//www.npmjs.com/package/idb)ライブラリを使用したIndexedDBの非同期カプセル化に基づいて開発されています。

IndexedDBの操作は、読み取りと書き込みの両方で非同期です。インデックスの作成中に、ドキュメントが同時にロードされてインデックスが構築されます。

競合書き込みによるデータ損失を防ぐために、次の`coffeescript`コードを参照してください。同時書き込みを遮断するために、読み取り操作と書き込み操作の間に`ing`プレフィックスを付けたキャッシュメカニズムを実装します。

```coffee
pusher = =>
  ing = new Map()
  (table, id, val)=>
    id_set = ing.get(id)
    if id_set
      id_set.add val
      return

    id_set = new Set([val])
    ing.set id, id_set
    pre = await table.get(id)
    li = pre?.li or []

    loop
      to_add = [...id_set]
      li.push(...to_add)
      await table.put({id,li})
      for i from to_add
        id_set.delete i
      if not id_set.size
        ing.delete id
        break
    return

rindexPush = pusher()
prefixPush = pusher()
```

## プレフィックスリアルタイム検索

ユーザーが入力している間、同時に検索結果を表示するため。たとえば、`Wor`を入力すると、`words`や`work`などの先頭に`Wor`が付いた単語が表示されます。

![](//p.3ti.site/1727684944.avif)

検索カーネルは、単語分割後の最後の単語に対して`prefix`テーブルを使用して、その単語で始まるすべての単語を検索し、順次検索を実行します。

アンチシェイク関数`debounce`は、検索をトリガーするユーザー入力の頻度と計算量を削減するために、フロントエンドインタラクション(次のように実装)でも採用されています。

```js
export default (wait, func) => {
  var timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(func.bind(this, ...args), wait);
  };
}
```

## 精度と再現率

検索では、まずユーザーが入力したキーワードに対して単語の分割が実行されます。

単語分割後の単語が`N`であるとします。結果を返す場合、最初にすべてのキーワードを含む結果が返され、次に`N-1`、`N-2`、...、`1`キーワードを含む結果が返されます。

優先表示される検索結果は、クエリの正確性を保証し、以降に読み込まれる結果(「もっと読む」ボタンをクリックして)は、再現率を保証します。

![](//p.3ti.site/1727684564.avif)

## ロードオンデマンド

応答速度を向上させるために、検索では`yield`ジェネレーターを使用してオンデマンド読み込みを実装し、クエリされた結果の数`limit`ごとに1回返します。

`yield`後で再度検索するたびに、`IndexedDB`のクエリトランザクションを再度開く必要があることに注意してください。

## プレフィックスリアルタイム検索

ユーザーが入力している間、同時に検索結果を表示するため。たとえば、`Wor`を入力すると、`words`や`work`などの先頭に`Wor`が付いた単語が表示されます。

![](//p.3ti.site/1727684944.avif)

検索カーネルは、単語分割後の最後の単語に対して`prefix`テーブルを使用して、その単語で始まるすべての単語を検索し、順次検索を実行します。

アンチシェイク関数`debounce`は、検索をトリガーするユーザー入力の頻度と計算量を削減するために、フロントエンドインタラクション(次のように実装)でも採用されています。

```js
export default (wait, func) => {
  var timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(func.bind(this, ...args), wait);
  };
}
```

## オフラインで利用可能

インデックステーブルには元のテキストは保存されず、単語のみが保存されるため、ストレージの量が削減されます。

検索結果を強調表示するには、元のテキストを再ロードする必要があり、`service worker`と調整することでネットワーク要求の繰り返しを回避できます。

同時に、`service worker`はすべての記事をキャッシュするため、ユーザーが検索を実行すると、検索を含むWebサイト全体がオフラインで利用できるようになります。

## Markdownドキュメントの表示の最適化

`i18n.site`の純粋なフロントエンド検索ソリューションは、`Markdown` ドキュメントに最適化されています。

検索結果の表示時には章名が表示され、クリックするとその章に移動します。

![](//p.3ti.site/1727686552.avif)

## 要約する

逆引き全文検索は、サーバーを必要とせず、フロントエンドのみに実装されます。ドキュメントや個人のブログなどの中小規模のWebサイトに非常に適しています。

オープンソースの自社開発の純粋なフロントエンド検索`i18n.site`は、サイズが小さく応答が速いため、現在の純粋なフロントエンド全文検索のさまざまな欠点が解決され、より良いユーザーエクスペリエンスが提供されます。