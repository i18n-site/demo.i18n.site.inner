---

brief: |
  i18n.site теперь поддерживает бессерверный полнотекстовый поиск.

  В этой статье представлена реализация чистой интерфейсной технологии полнотекстового поиска, включающей инвертированный индекс, созданный IndexedDB, префиксный поиск, оптимизацию сегментации слов и поддержку нескольких языков.

  По сравнению с существующими решениями, чисто интерфейсный полнотекстовый поиск i18n.site имеет небольшой размер и скорость, подходит для небольших и средних веб-сайтов, таких как документы и блоги, и доступен в автономном режиме.

---

# Чистый Интерфейс, Инвертированный Полнотекстовый Поиск

## Последовательность

После нескольких недель разработки [i18n.site](//i18n.site) (чисто статический многоязычный инструмент для перевода и создания веб-сайтов с уценкой) теперь поддерживает полнотекстовый поиск в чистом интерфейсе.

<p style="display:flex;flex-wrap:wrap;justify-content:center"><img src="//p.3ti.site/1727600475.avif" style="width:320px"><img src="//p.3ti.site/1727602760.avif" style="width:320px"></p>

В этой статье будет представлена техническая реализация полнотекстового поиска в интерфейсе `i18n.site` . Посетите [i18n.site,](//i18n.site) чтобы ощутить эффект поиска.

Код с открытым исходным кодом: [ядро поиска](//github.com/i18n-site/ie/tree/main/qy) / [интерактивный интерфейс.](//github.com/i18n-site/plugin/tree/main/qy)

## Обзор Решений Для Бессерверного Полнотекстового Поиска

Для небольших и средних чисто статических веб-сайтов, таких как документы/личные блоги, создание самостоятельного механизма полнотекстового поиска является слишком громоздким, и более распространенным выбором является бессерверный полнотекстовый поиск.

Решения для бессерверного полнотекстового поиска можно разделить на две большие категории:

Во-первых, аналогично сторонним поставщикам поисковых услуг [algolia.com](//algolia.com) , которые предоставляют внешние компоненты для полнотекстового поиска.

Такие услуги требуют оплаты в зависимости от объема поиска и часто недоступны для пользователей в материковом Китае из-за таких проблем, как соответствие веб-сайта требованиям.

Его нельзя использовать в автономном режиме или в интранете, и он имеет серьезные ограничения. В этой статье это не обсуждается.

Второй — чистый полнотекстовый поиск во внешнем интерфейсе.

В настоящее время к распространенным полнотекстовым поискам на чистом интерфейсе относятся [lunrjs](//lunrjs.com) и [ElasticLunr.js](//github.com/weixsong/elasticlunr.js) (на основе вторичной разработки `lunrjs` ).

Есть два способа построения индексов в `lunrjs` , и оба имеют свои проблемы.

1. Готовые индексные файлы

   Поскольку индекс содержит слова из всех документов, он громоздкий.
   При каждом добавлении или изменении документа необходимо загрузить новый индексный файл.
   Это увеличит время ожидания пользователя и потребует большую часть полосы пропускания.

2. Загружайте документы и создавайте индексы на лету

   Построение индекса представляет собой трудоемкую вычислительную задачу. Перестроение индекса каждый раз при доступе к нему приведет к очевидным задержкам и ухудшению пользовательского опыта.

---

Помимо `lunrjs` , существуют и другие решения для полнотекстового поиска, например:

[fusejs](//www.fusejs.io) , который вычисляет сходство между строками для поиска.

Производительность этого решения крайне низкая и его нельзя использовать для полнотекстового поиска (см. [Fuse.js Длинный запрос занимает более 10 секунд, как оптимизировать?](//stackoverflow.com/questions/70984437/fuse-js-takes-10-seconds-with-semi-long-queries) ).

[TinySearch](//github.com/tinysearch/tinysearch) , который использует для поиска фильтр Блума, не может использоваться для поиска по префиксу (например, введите `goo` , выполните поиск `good` , `google` ) и не может достичь аналогичного эффекта автоматического завершения.

Из-за недостатков существующих решений `i18n.site` разработала новое чисто интерфейсное решение для полнотекстового поиска со следующими характеристиками:

1. Поддерживает многоязычный поиск и имеет компактные размеры. Размер поискового ядра после упаковки с `gzip` равен `6.9KB` (для сравнения размер `lunrjs` равен `25KB` )
1. Создает инвертированный индекс на основе `indexedb` , который занимает меньше памяти и работает быстрее.
1. При добавлении/изменении документов переиндексируются только добавленные или измененные документы, что сокращает объем вычислений.
1. Поддерживает префиксный поиск, который может отображать результаты поиска в режиме реального времени, пока пользователь печатает.
1. Доступно Офлайн

Ниже будут подробно представлены детали технической реализации `i18n.site` .

## Многоязычная Сегментация Слов

Сегментация слов использует собственную сегментацию слов `Intl.Segmenter` браузера, и все основные браузеры поддерживают этот интерфейс.

![](//p.3ti.site/1727667759.avif)

Код сегментации слова `coffeescript` выглядит следующим образом:

```coffee
SEG = new Intl.Segmenter 0, granularity: "word"

seg = (txt) =>
  r = []
  for {segment} from SEG.segment(txt)
    for i from segment.split('.')
      i = i.trim()
      if i and !'|`'.includes(i) and !/\p{P}/u.test(i)
        r.push i
  r

export default seg

export segqy = (q) =>
  seg q.toLocaleLowerCase()
```

в котором:

* `/\p{P}/` — это шаблон регулярного выражения, используемый для сопоставления знаков препинания. Конкретные символы, которым он соответствует, включают: `! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~. `.</p><ul><li> ` Split('.') `is because` Firefox `browser word segmentation does not segment` .` .</li>


## Построение Индекса

База данных `IndexedDB` содержит 5 таблиц хранения объектов:

* `word` : идентификатор – слово
* `doc` : id — URL-адрес документа — номер версии документа.
* `docWord` : Массив идентификатора документа — идентификатор слова
* `prefix` : Массив префикса — идентификатор слова
* `rindex` : идентификатор слова — идентификатор документа: массив номеров строк.

Передайте массив документа `url` и номера версии `ver` и проверьте, существует ли документ в таблице `doc` . Если он не существует, создайте инвертированный индекс. Одновременно удалите записи инвертированного индекса для документов, которые не включены во входные данные.

Таким образом достигается инкрементная индексация, что, в свою очередь, снижает вычислительную нагрузку.

Что касается внешнего взаимодействия, может отображаться индикатор выполнения индексации, чтобы предотвратить задержку во время начальной загрузки. См. «Индикатор прогресса с анимацией: единый прогресс + реализация на чистом CSS» [на английском](//dev.to/i18n-site/a-single-progress-uses-pure-css-to-achieve-animation-effects-2oo) / [китайском языках](//juejin.cn/post/7413586285954154522) .

### Написание IndexedDB С Высоким Параллелизмом

Проект разработан на основе асинхронной инкапсуляции IndexedDB с использованием библиотеки [idb](//www.npmjs.com/package/idb) .

Операции IndexedDB, как чтение, так и запись, являются асинхронными. Во время создания индекса документы загружаются одновременно для построения индекса.

Чтобы предотвратить потерю данных из-за конкурентной записи, используйте следующий код `coffeescript` . Реализуйте механизм кэширования с префиксом `ing` между операциями чтения и записи для перехвата параллельных операций записи.

```coffee
pusher = =>
  ing = new Map()
  (table, id, val)=>
    id_set = ing.get(id)
    if id_set
      id_set.add val
      return

    id_set = new Set([val])
    ing.set id, id_set
    pre = await table.get(id)
    li = pre?.li or []

    loop
      to_add = [...id_set]
      li.push(...to_add)
      await table.put({id,li})
      for i from to_add
        id_set.delete i
      if not id_set.size
        ing.delete id
        break
    return

rindexPush = pusher()
prefixPush = pusher()
```

## Префиксный Поиск В Реальном Времени

Чтобы представить результаты поиска одновременно, пока пользователь вводит данные. Например, если ввести ` Wor` , будут отображаться такие слова, как `words` и `work` , с префиксом ` Wor` .

![](//p.3ti.site/1727684944.avif)

Ядро поиска будет использовать таблицу `prefix` для последнего слова после сегментации слова, чтобы найти все слова с его префиксом и провести последовательный поиск.

Функция защиты от сотрясений `debounce` также используется во внешнем взаимодействии (реализована следующим образом) для уменьшения частоты запросов, запускающих ввод пользователя, и объема вычислений.

```js
export default (wait, func) => {
  var timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(func.bind(this, ...args), wait);
  };
}
```

## Точность И Скорость Отзыва

Поиск сначала выполнит сегментацию слов по ключевым словам, введенным пользователем.

Предположим, что после сегментации слов осталось `N` слов. При возврате результатов сначала будут возвращены результаты, содержащие все ключевые слова, а затем результаты, содержащие ключевые слова `N-1` , `N-2` ,..., `1` .

Отображаемые результаты поиска преимущественно обеспечивают точность запроса, а последующие загружаемые результаты (при нажатии кнопки «Загрузить еще») обеспечивают скорость отзыва.

![](//p.3ti.site/1727684564.avif)

## Загрузка по требованию

Чтобы повысить скорость ответа, поиск использует генератор `yield` для реализации загрузки по требованию и возвращает один раз для каждого `limit` числа запрошенных результатов.

Обратите внимание, что каждый раз после `yield` и при повторном поиске необходимо заново открывать транзакцию запроса `IndexedDB` .

## Префиксный Поиск В Реальном Времени

Чтобы представить результаты поиска одновременно, пока пользователь вводит данные. Например, если ввести ` Wor` , будут отображаться такие слова, как `words` и `work` , с префиксом ` Wor` .

![](//p.3ti.site/1727684944.avif)

Ядро поиска будет использовать таблицу `prefix` для последнего слова после сегментации слова, чтобы найти все слова с его префиксом и провести последовательный поиск.

Функция защиты от сотрясений `debounce` также используется во внешнем взаимодействии (реализована следующим образом) для уменьшения частоты запросов, запускающих ввод пользователя, и объема вычислений.

```js
export default (wait, func) => {
  var timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(func.bind(this, ...args), wait);
  };
}
```

## Доступно Офлайн

В индексной таблице хранится не исходный текст, а только слова, что уменьшает объем памяти.

Для выделения результатов поиска требуется перезагрузка исходного текста, а согласование с `service worker` позволяет избежать повторных сетевых запросов.

В то же время, поскольку `service worker` кэширует все статьи, после того как пользователь выполнил поиск, весь веб-сайт, включая поиск, становится доступен в автономном режиме.

## Оптимизация Отображения Документов MarkDown

Чистое решение для внешнего поиска `i18n.site` оптимизировано для `MarkDown` документов.

При отображении результатов поиска будет отображаться название главы, и при нажатии на нее будет выполнен переход к этой главе.

![](//p.3ti.site/1727686552.avif)

## Подвести Итог

Инвертированный полнотекстовый поиск, реализованный исключительно во внешнем интерфейсе, без необходимости использования сервера. Он очень подходит для небольших и средних веб-сайтов, таких как документы и личные блоги.

Самостоятельно разработанный чистый интерфейсный поиск с открытым исходным кодом `i18n.site` , небольшой размер и быстрый отклик устраняет различные недостатки текущего внешнего полнотекстового поиска и обеспечивает лучший пользовательский опыт.